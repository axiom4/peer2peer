<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>P2P Filesystem</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
      /* Full height layout */
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden; /* Prevent body scroll */
      }
      .container {
        height: 100%;
        display: flex;
        flex-direction: column;
        padding-bottom: 0px !important;
      }
      /* Ensure the card wrapper grows to fill space */
      .fs-grow {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        margin-bottom: 1rem !important;
      }
      #fsCard {
        height: 100%;
        display: flex;
        flex-direction: column;
      }
      #fsCard .card-body {
        flex: 1;
        overflow-y: auto;
        min-height: 0; /* Flexbox scroll fix */
      }
      #uploadStatus {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 300px;
        z-index: 1050; /* Above everything */
        background: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: none; /* Hidden by default */
        border: 1px solid #dee2e6;
      }
      /* Show when it has content (script will handle display block/none) */
      #uploadStatus.active {
        display: block;
      }
      /* Tree View Styles */
      .tree-item {
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .tree-item:hover {
        background-color: #e9ecef;
      }
      .tree-item.active {
        background-color: #0d6efd;
        color: white !important;
      }
      .tree-group {
        padding-left: 20px;
        display: none;
      }
      .tree-group.show {
        display: block;
      }
      .tree-toggle {
        cursor: pointer;
        width: 20px;
        display: inline-block;
        text-align: center;
        color: #6c757d;
      }
      .tree-toggle:hover {
        color: #0d6efd;
      }
    </style>
  </head>
  <body class="bg-light">
    <div class="container-fluid py-4 px-4 main-container" style="height: 100%; display: flex; flex-direction: column">
      <header class="pb-3 mb-4 border-bottom d-flex justify-content-between align-items-center flex-shrink-0">
        <a href="/" class="d-flex align-items-center text-dark text-decoration-none">
          <span class="fs-4">P2P Storage System</span>
        </a>
        <nav>
          <a href="/" class="btn btn-outline-primary me-2"><i class="fas fa-tachometer-alt me-1"></i> Dashboard</a>
          <a href="/filesystem" class="btn btn-primary me-2"><i class="fas fa-folder me-1"></i> Filesystem</a>
          <a href="/topology" class="btn btn-outline-primary"><i class="fas fa-project-diagram me-1"></i> Network Topology</a>
        </nav>
      </header>

      <!-- Hidden inputs for upload logic -->
      <input type="file" id="fileInput" style="display: none" onchange="handleFileInputChange(event)" />
      <!-- Defaults for drag-drop upload -->
      <input type="hidden" id="replicasInput" value="5" />
      <input type="checkbox" id="compressionCheck" checked style="display: none" />

      <!-- Upload Status Container (Floating) -->
      <div id="uploadStatus"></div>

      <div class="row g-4 mb-4 flex-grow-1" style="min-height: 0">
        <!-- Left Column: Navigation Tree -->
        <div class="col-lg-3 d-flex flex-column h-100">
          <div class="card h-100 d-flex flex-column">
            <div class="card-header bg-light fw-bold d-flex justify-content-between align-items-center">
              <span><i class="fas fa-sitemap me-2 text-secondary"></i> Allowed Folders</span>
              <button class="btn btn-sm btn-outline-primary" onclick="promptMkdir()" title="New Folder"><i class="fas fa-folder-plus"></i></button>
            </div>
            <div class="card-body p-2" style="overflow-y: auto">
              <div id="fsTreeRoot">
                <!-- Tree will be injected here -->
                <div class="d-flex align-items-center tree-item" onclick="loadFilesystem('/')"><i class="fas fa-hdd text-secondary me-2"></i> Root</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Right Column: File Browser -->
        <div class="col-lg-9 d-flex flex-column h-100">
          <div class="card h-100 d-flex flex-column" id="fsCard" ondragover="handleFileDragOver(event)" ondragleave="handleFileDragLeave(event)" ondrop="handleFileDrop(event)">
            <div class="card-header bg-success text-white d-flex justify-content-between align-items-center flex-shrink-0">
              <span>ðŸ“‚ Decentralized Filesystem</span>
              <div>
                <i id="fsLoading" class="fas fa-sync fa-spin text-white me-2" style="display: none"></i>
                <button class="btn btn-sm btn-light" onclick="triggerFsUpload()"><i class="fas fa-upload"></i> Upload Here</button>
              </div>
            </div>
            <div class="card-body bg-white d-flex flex-column p-0" style="min-height: 0">
              <nav aria-label="breadcrumb" class="p-3 pb-0">
                <ol class="breadcrumb bg-light p-2 rounded mb-2" id="fsBreadcrumbs">
                  <li class="breadcrumb-item active" aria-current="page">/</li>
                </ol>
              </nav>
              <div class="table-responsive flex-grow-1">
                <table class="table table-hover align-middle mb-0">
                  <thead class="table-light sticky-top">
                    <tr>
                      <th style="width: 40px"></th>
                      <th>Name</th>
                      <th style="width: 100px">Type</th>
                      <th style="width: 100px">Size</th>
                      <th style="width: 150px">Actions</th>
                    </tr>
                  </thead>
                  <tbody id="fsFileList">
                    <tr>
                      <td colspan="5" class="text-center text-muted">Loading filesystem...</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div class="card-footer text-muted small flex-shrink-0">Drag and drop files to move them to subfolders. Drop a local file to upload it here.</div>
          </div>
        </div>
      </div>

      <!-- Modal for Distribution Graph -->
      <div class="modal fade" id="distModal" tabindex="-1">
        <div class="modal-dialog modal-xl">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">File Distribution Map</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
              <div id="dist-graph" style="width: 100%; height: 500px; border: 1px solid #ddd"></div>
            </div>
          </div>
        </div>
      </div>

      <footer class="pt-3 mt-4 text-muted border-top">&copy; 2026 P2P Storage System</footer>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      function formatBytes(bytes, decimals = 2) {
        if (!+bytes) return "0 Bytes";
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
      }

      // --- Filesystem Logic ---
      let currentFsPath = "/";

      // Global variable to track distribution network instance
      let distNetwork = null;

      async function showDistributionGraph(identifier, isPublic = true) {
        const modal = new bootstrap.Modal(document.getElementById("distModal"));
        modal.show();

        const graphContainer = document.getElementById("dist-graph");
        // Clear and show loading state
        graphContainer.innerHTML =
          '<div class="d-flex justify-content-center align-items-center h-100 flex-column"><div class="spinner-border text-primary"></div><div class="mt-2 text-muted">Discovery in progress...</div></div>';

        try {
          // FS entries have an ID, which is the manifest hash. So we can use /api/manifests/id/{id}
          // Note: In Filesystem view, we always identify files by ID (hash), so isPublic=true logic (using ID endpoint) is correct.
          const url = `/api/manifests/id/${identifier}`;

          const res = await fetch(url);
          if (!res.ok) throw new Error("Failed to load map data");
          const manifest = await res.json();

          // Clear loading spinner
          graphContainer.innerHTML = "";

          const nodes = [];
          const edges = [];
          const ids = new Set();

          const sortedChunks = manifest.chunks.sort((a, b) => a.index - b.index);

          // Collect all unique Hosts first to create specific nodes
          const hostSet = new Set();
          sortedChunks.forEach((c) => {
            (c.locations || []).forEach((loc) => hostSet.add(loc));
          });

          // Add Hosts as Nodes
          hostSet.forEach((loc) => {
            const label = loc.split(":").pop();
            nodes.push({
              id: loc,
              label: label,
              color: "#4CAF50",
              size: 25,
              shape: "ellipse",
            });
            ids.add(loc);
          });

          // Add Start Node (Source)
          nodes.push({ id: "SOURCE", label: "START", color: "#FF9800", size: 30, shape: "database" });
          ids.add("SOURCE");

          // Build edges based on sequence: SOURCE -> Chunks(0) -> Chunks(1) ...
          let prevHosts = ["SOURCE"];

          sortedChunks.forEach((chunk, idx) => {
            const chunkLabel = `C${chunk.index}`;
            const currentHosts = chunk.locations || [];

            if (currentHosts.length > 0) {
              const uniqueCurr = [...new Set(currentHosts)];

              if (prevHosts.length > 0) {
                uniqueCurr.forEach((curr, currIdx) => {
                  let prev = prevHosts[currIdx % prevHosts.length];
                  edges.push({
                    from: prev,
                    to: curr,
                    label: chunkLabel,
                    arrows: "to",
                    color: "#2196F3",
                    font: { align: "horizontal", size: 10, background: "white" },
                  });
                });
              }
              prevHosts = uniqueCurr;
            } else {
              prevHosts = [];
            }
          });

          const container = document.getElementById("dist-graph");
          const data = { nodes: nodes, edges: edges };

          const options = {
            layout: {
              improvedLayout: true,
              randomSeed: 2,
            },
            physics: {
              enabled: true,
              solver: "barnesHut",
              barnesHut: {
                gravitationalConstant: -2000,
                centralGravity: 0.3,
                springLength: 200,
                springConstant: 0.04,
                damping: 0.09,
                avoidOverlap: 0.5,
              },
              stabilization: {
                iterations: 1000,
              },
            },
            edges: {
              smooth: {
                type: "continuous",
              },
            },
          };

          // Wait for modal and destroy previous
          setTimeout(() => {
            if (distNetwork) distNetwork.destroy();
            distNetwork = new vis.Network(container, data, options);
          }, 500);
        } catch (e) {
          document.getElementById("dist-graph").innerText = "Error loading map: " + e;
        }
      }

      // Init
      document.addEventListener("DOMContentLoaded", function () {
        console.log("Initializing Filesystem...");
        loadFilesystem("/")
          .then(() => console.log("Filesystem loaded"))
          .catch((e) => console.error("FS Load Error:", e));

        // Init Tree
        refreshTreeRoot();
      });

      // --- Tree Logic ---

      // Refresh the currently active tree node (node corresponding to currentFsPath)
      // This ensures that if we added/removed folders, the tree reflects it WITHOUT collapsing everything.
      async function refreshActiveTreeNode() {
        const activeItem = document.querySelector(`.tree-item[data-path="${currentFsPath}"]`);
        if (activeItem) {
          const parentDiv = activeItem.parentElement;
          const group = parentDiv.nextElementSibling; // .tree-group
          // Only reload if it is already expanded (has .show class)
          // or if we want to force expansion? Maybe just reload if known.
          // Usually we just want to update content.
          if (group && group.classList.contains("show")) {
            await loadTreePath(currentFsPath, group);
          } else {
            // If not expanded, we might want to at least ensure the arrow is correct?
            // But loadTreePath handles content.
            // If it was empty and now has content, we might want to update the toggle icon?
            // But toggle logic handles lazy load.
          }
        }
      }

      async function refreshTreeRoot() {
        const rootContainer = document.getElementById("fsTreeRoot");
        rootContainer.innerHTML = "";

        // Creates the Root Node
        const rootDiv = document.createElement("div");
        rootDiv.innerHTML = `
            <div class="d-flex align-items-center">
                <span class="tree-toggle" onclick="toggleTreeNode(event, '/', this)"><i class="fas fa-chevron-right"></i></span>
                <div class="tree-item flex-grow-1" onclick="loadFilesystem('/')" data-path="/">
                    <i class="fas fa-hdd text-warning me-2"></i> Root
                </div>
            </div>
            <div class="tree-group" id="group-root"></div>
        `;
        rootContainer.appendChild(rootDiv);

        // Auto-expand root
        const toggleBtn = rootDiv.querySelector(".tree-toggle");
        toggleTreeNode(null, "/", toggleBtn);
      }

      async function toggleTreeNode(ev, path, toggleEl) {
        if (ev) ev.stopPropagation();
        const group = toggleEl.parentElement.nextElementSibling; // The div.tree-group
        const isExpanded = group.classList.contains("show");

        if (isExpanded) {
          group.classList.remove("show");
          toggleEl.innerHTML = '<i class="fas fa-chevron-right"></i>';
        } else {
          group.classList.add("show");
          toggleEl.innerHTML = '<i class="fas fa-chevron-down"></i>';
          if (group.children.length === 0) {
            // Lazy load
            await loadTreePath(path, group);
          }
        }
      }

      async function loadTreePath(path, container) {
        container.innerHTML = '<div class="text-muted small ps-4">Loading...</div>';
        try {
          const res = await fetch(`/api/fs/ls?path=${encodeURIComponent(path)}`);
          const data = await res.json();
          container.innerHTML = "";

          if (!data.entries) return;

          // Filter directories only
          const dirs = data.entries.filter((e) => e.type === "directory");
          dirs.sort((a, b) => a.name.localeCompare(b.name));

          if (dirs.length === 0) {
            container.innerHTML = '<div class="text-muted small ps-4"><i>Empty</i></div>';
            return;
          }

          dirs.forEach((dir) => {
            const dirPath = path === "/" ? `/${dir.name}` : `${path}/${dir.name}`;
            const node = document.createElement("div");
            node.innerHTML = `
                    <div class="d-flex align-items-center">
                        <span class="tree-toggle" onclick="toggleTreeNode(event, '${dirPath}', this)"><i class="fas fa-chevron-right"></i></span>
                        <div class="tree-item flex-grow-1" onclick="loadFilesystem('${dirPath}')" data-path="${dirPath}">
                            <i class="fas fa-folder text-warning me-2"></i> ${dir.name}
                        </div>
                    </div>
                    <div class="tree-group"></div>
                  `;
            container.appendChild(node);
          });
        } catch (e) {
          container.innerHTML = `<div class="text-danger small ps-4">Error</div>`;
        }
      }

      async function loadFilesystem(path = "/") {
        currentFsPath = path;
        renderBreadcrumbs(path);

        // Highlight active tree item
        document.querySelectorAll(".tree-item").forEach((el) => el.classList.remove("active"));
        const activeItem = document.querySelector(`.tree-item[data-path="${path}"]`);
        if (activeItem) activeItem.classList.add("active");

        const tbody = document.getElementById("fsFileList");
        if (document.getElementById("fsLoading")) document.getElementById("fsLoading").style.display = "inline-block";

        try {
          const res = await fetch(`/api/fs/ls?path=${encodeURIComponent(path)}`);
          const data = await res.json();

          tbody.innerHTML = "";

          if (data.path !== "/") {
            const parentPath = currentFsPath.substring(0, currentFsPath.lastIndexOf("/")) || "/";
            const tr = document.createElement("tr");

            // Allow dropping on parent folder ".."
            tr.setAttribute("ondragover", "handleDragOver(event)");
            tr.setAttribute("ondrop", "handleDrop(event, '..')");
            tr.setAttribute("ondragleave", "handleDragLeave(event)");

            tr.innerHTML = `
                 <td><i class="fas fa-folder-open text-warning fa-lg"></i></td>
                 <td><a href="#" onclick="loadFilesystem('${parentPath}'); return false;" class="text-decoration-none text-dark fw-bold">..</a></td>
                 <td>Dir</td>
                 <td>-</td>
                 <td></td>
               `;
            tbody.appendChild(tr);
          }

          if (data.entries && data.entries.length > 0) {
            data.entries.sort((a, b) => {
              if (a.type === b.type) return a.name.localeCompare(b.name);
              return a.type === "directory" ? -1 : 1;
            });

            data.entries.forEach((entry) => {
              const tr = document.createElement("tr");
              const icon = entry.type === "directory" ? "fa-folder text-warning" : "fa-file-alt text-secondary";

              // Drag and Drop attributes
              tr.setAttribute("draggable", "true");
              tr.setAttribute("ondragstart", `handleDragStart(event, '${entry.name}', '${entry.type}')`);

              // If directory, it can accept drops
              if (entry.type === "directory") {
                tr.setAttribute("ondragover", "handleDragOver(event)");
                tr.setAttribute("ondrop", `handleDrop(event, '${entry.name}')`);
                tr.setAttribute("ondragleave", "handleDragLeave(event)");
              }

              let nameLink = entry.name;
              if (entry.type === "directory") {
                const nextPath = path === "/" ? `/${entry.name}` : `${path}/${entry.name}`;
                nameLink = `<a href="#" onclick="loadFilesystem('${nextPath}'); return false;" class="fw-bold text-decoration-none text-dark">${entry.name}</a>`;
              }

              tr.innerHTML = `
                     <td><i class="fas ${icon} fa-lg"></i></td>
                     <td>${nameLink}</td>
                     <td>${entry.type}</td>
                     <td>${entry.type === "file" ? formatBytes(entry.size) : "-"}</td>
                     <td>
                        <div class="btn-group">
                        ${
                          entry.type === "file"
                            ? `<button class="btn btn-sm btn-outline-primary" onclick="window.location.href='/api/stream_id/${entry.id}'"><i class="fas fa-download"></i></button>`
                            : ""
                        }
                        ${
                          entry.type === "file"
                            ? `<button class="btn btn-sm btn-outline-info" onclick="showDistributionGraph('${entry.id}')" title="Chunk Map"><i class="fas fa-project-diagram"></i></button>`
                            : ""
                        }
                        <button class="btn btn-sm btn-outline-danger" onclick="deleteFsEntry('${entry.name}')"><i class="fas fa-trash"></i></button>
                        </div>
                     </td>
                   `;
              tbody.appendChild(tr);
            });
          } else {
            if (tbody.children.length === 0) tbody.innerHTML = '<tr><td colspan="5" class="text-center text-muted">Empty directory</td></tr>';
          }
        } catch (e) {
          console.error(e);
          tbody.innerHTML = `<tr><td colspan="5" class="text-center text-danger">Error: ${e}</td></tr>`;
        } finally {
          if (document.getElementById("fsLoading")) document.getElementById("fsLoading").style.display = "none";
        }
      }

      function renderBreadcrumbs(path) {
        const nav = document.getElementById("fsBreadcrumbs");
        nav.innerHTML = "";

        const parts = path.split("/").filter((p) => p);

        const rootLi = document.createElement("li");
        rootLi.className = "breadcrumb-item";
        if (parts.length === 0) {
          rootLi.classList.add("active");
          rootLi.innerText = "Root";
        } else {
          rootLi.innerHTML = `<a href="#" onclick="loadFilesystem('/'); return false;">Root</a>`;
        }
        nav.appendChild(rootLi);

        let accum = "";
        parts.forEach((part, idx) => {
          accum += "/" + part;
          accum = accum.replace("//", "/");

          const li = document.createElement("li");
          li.className = "breadcrumb-item";
          if (idx === parts.length - 1) {
            li.classList.add("active");
            li.innerText = part;
          } else {
            li.innerHTML = `<a href="#" onclick="loadFilesystem('${accum}'); return false;">${part}</a>`;
          }
          nav.appendChild(li);
        });
      }

      async function deleteFsEntry(name) {
        if (!confirm(`Are you sure you want to delete '${name}'?`)) return;

        try {
          const res = await fetch("/api/fs/delete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              path: currentFsPath,
              name: name,
            }),
          });
          const result = await res.json();
          if (res.ok) {
            loadFilesystem(currentFsPath);
            refreshActiveTreeNode();
          } else {
            alert("Error: " + (result.error || result.message));
          }
        } catch (e) {
          alert("Error: " + e);
        }
      }

      async function promptMkdir() {
        const name = prompt("Enter folder name:");
        if (!name) return;

        try {
          const res = await fetch("/api/fs/mkdir", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              path: currentFsPath,
              name: name,
            }),
          });
          const result = await res.json();
          if (res.ok) {
            loadFilesystem(currentFsPath);
            refreshActiveTreeNode();
          } else {
            alert("Error: " + result.error);
          }
        } catch (e) {
          alert("Error: " + e);
        }
      }

      function triggerFsUpload() {
        const input = document.getElementById("fileInput");
        input.click();
      }

      function handleFileInputChange(event) {
        const file = event.target.files[0];
        if (file) {
          uploadFileDirectly(file);
        }
        // Reset input so same file can be selected again if needed
        event.target.value = "";
      }

      async function addFileToFs(manifestId, filename, size, targetPath = null) {
        const path = targetPath || currentFsPath;
        try {
          const res = await fetch("/api/fs/add_file", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              path: path,
              name: filename,
              id: manifestId,
              size: size,
            }),
          });
          const result = await res.json();
          if (res.ok) {
            if (path === currentFsPath) loadFilesystem(currentFsPath);
          } else {
            console.warn("Error adding to filesystem: " + result.error);
          }
        } catch (e) {
          console.error(e);
        }
      }

      // --- Drag and Drop Logic ---

      function handleDragStart(ev, name, type) {
        ev.stopPropagation();
        ev.dataTransfer.setData("text/plain", JSON.stringify({ name: name, type: type, srcPath: currentFsPath }));
        ev.dataTransfer.effectAllowed = "move";
      }

      function handleDragOver(ev) {
        ev.preventDefault();
        ev.stopPropagation(); // Stop bubbling to card
        ev.dataTransfer.dropEffect = "move";
        ev.currentTarget.classList.add("table-active");
      }

      function handleDragLeave(ev) {
        ev.currentTarget.classList.remove("table-active");
      }

      async function handleDrop(ev, destName) {
        ev.preventDefault();
        ev.stopPropagation(); // Stop bubbling to card
        ev.currentTarget.classList.remove("table-active");

        const rawData = ev.dataTransfer.getData("text/plain");
        if (!rawData) return;

        try {
          const data = JSON.parse(rawData);
          const sourceName = data.name;

          if (sourceName === destName) return;

          let destPath = currentFsPath;
          if (destName === "..") {
            destPath = currentFsPath.substring(0, currentFsPath.lastIndexOf("/")) || "/";
          } else {
            destPath = (currentFsPath === "/" ? "" : currentFsPath) + "/" + destName;
          }

          const confirmMove = confirm(`Move '${sourceName}' to '${destName}'?`);
          if (!confirmMove) return;

          const payload = {
            source_path: currentFsPath,
            source_name: sourceName,
            dest_path: destPath,
          };

          const res = await fetch("/api/fs/move", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          const result = await res.json();
          if (res.ok) {
            loadFilesystem(currentFsPath);
            refreshActiveTreeNode();
          } else {
            alert("Move failed: " + (result.error || "Unknown error"));
          }
        } catch (e) {
          console.error("Drop error", e);
        }
      }

      // External File Drop (Upload with Folder Support)
      function handleFileDragOver(ev) {
        ev.preventDefault();
        ev.dataTransfer.dropEffect = "copy";
        document.getElementById("fsCard").classList.add("border-primary", "border-3");
      }

      function handleFileDragLeave(ev) {
        document.getElementById("fsCard").classList.remove("border-primary", "border-3");
      }

      async function handleFileDrop(ev) {
        ev.preventDefault();
        document.getElementById("fsCard").classList.remove("border-primary", "border-3");

        const items = ev.dataTransfer.items;
        if (!items || items.length === 0) return;

        if (!confirm(`Upload ${items.length} items to current folder?`)) return;

        // Process all items
        for (let i = 0; i < items.length; i++) {
          const item = items[i].webkitGetAsEntry();
          if (item) {
            await traverseFileTree(item);
          }
        }

        // Refresh UI
        loadFilesystem(currentFsPath);
        refreshActiveTreeNode();
      }

      async function traverseFileTree(item) {
        if (item.isFile) {
          return new Promise((resolve, reject) => {
            item.file(
              (file) => {
                const relativeFolder = item.fullPath.substring(0, item.fullPath.lastIndexOf("/"));
                const targetDir = (currentFsPath === "/" ? "" : currentFsPath) + relativeFolder;

                ensureDirectory(targetDir)
                  .then(() => {
                    // Upload and wait for completion to serialize uploads
                    return uploadFileDirectly(file, targetDir);
                  })
                  .then(resolve)
                  .catch((e) => {
                    console.error("Upload failed", e);
                    resolve(); // Continue anyway
                  });
              },
              (e) => resolve()
            );
          });
        } else if (item.isDirectory) {
          // Create directory
          const dirPath = (currentFsPath === "/" ? "" : currentFsPath) + item.fullPath;
          await ensureDirectory(dirPath);

          const dirReader = item.createReader();
          const entries = await getAllEntries(dirReader);

          for (const entry of entries) {
            await traverseFileTree(entry);
          }
        }
      }

      function getAllEntries(dirReader) {
        return new Promise((resolve, reject) => {
          let entriesList = [];
          const read = () => {
            dirReader.readEntries(
              (results) => {
                if (!results.length) {
                  resolve(entriesList);
                } else {
                  entriesList = entriesList.concat(results);
                  read();
                }
              },
              (e) => reject(e)
            );
          };
          read();
        });
      }

      async function ensureDirectory(fullPath) {
        if (!fullPath || fullPath === "/") return;
        const lastSlash = fullPath.lastIndexOf("/");
        const parentPath = fullPath.substring(0, lastSlash) || "/";
        const newName = fullPath.substring(lastSlash + 1);

        try {
          await fetch("/api/fs/mkdir", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ path: parentPath, name: newName }),
          });
        } catch (e) {
          console.warn("Mkdir error", e);
        }
      }

      function uploadFileDirectly(file, targetPath = null) {
        return new Promise((resolve, reject) => {
          const replicas = document.getElementById("replicasInput").value || 5;
          const compression = document.getElementById("compressionCheck").checked;
          const targetFsPath = targetPath || currentFsPath;

          const formData = new FormData();
          formData.append("file", file);
          formData.append("redundancy", replicas);
          formData.append("compression", compression);

          const statusDiv = document.getElementById("uploadStatus");
          statusDiv.className = "active"; // Show container
          statusDiv.innerHTML = `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <strong class="small">Uploading ${file.name}</strong>
                    <button type="button" class="btn-close btn-close-sm" onclick="document.getElementById('uploadStatus').classList.remove('active')"></button>
                </div>
                <div class="progress mb-2" style="height: 15px;">
                    <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                </div>
                <div id="statusText" class="text-muted small" style="font-size: 0.8em">Starting...</div>
              `;

          const xhr = new XMLHttpRequest();
          xhr.open("POST", "/api/upload", true);

          xhr.upload.onprogress = (event) => {
            if (event.lengthComputable) {
              const percent = Math.round((event.loaded / event.total) * 100);
              const progressBar = document.getElementById("progressBar");
              const visualPercent = Math.round(percent * 0.4); // UI Trick: Upload is 40%

              if (progressBar) {
                progressBar.style.width = visualPercent + "%";
                progressBar.innerText = visualPercent + "%";
              }
            }
          };

          xhr.onload = () => {
            if (xhr.status === 200) {
              try {
                const result = JSON.parse(xhr.responseText);
                if (result.status === "processing" && result.task_id) {
                  const taskId = result.task_id;
                  const progressBar = document.getElementById("progressBar");
                  const statusText = document.getElementById("statusText");

                  if (progressBar) progressBar.classList.add("bg-success");

                  const pollInterval = setInterval(async () => {
                    try {
                      const res = await fetch(`/api/progress/${taskId}`);
                      const task = await res.json();

                      if (task.status === "completed") {
                        clearInterval(pollInterval);
                        if (progressBar) {
                          progressBar.style.width = "100%";
                          progressBar.innerText = "100%";
                        }
                        if (statusText) statusText.innerText = task.message;

                        const match = task.message.match(/Manifest ID: ([a-f0-9]{64})/i);
                        if (match && match[1]) {
                          // Add to FS but don't auto-close immediately if we want to show success
                          await addFileToFs(match[1], file.name, file.size, targetFsPath);
                        }

                        // Complete Promise
                        resolve(match ? match[1] : true);

                        // Hide after short delay to allow visual confirmation
                        setTimeout(() => {
                          // Only hide if it's the same upload (simplified logic: just hide)
                          // In serial mode, next upload will show it again immediately.
                          statusDiv.classList.remove("active");
                        }, 1000);
                      } else if (task.status === "error") {
                        clearInterval(pollInterval);
                        statusDiv.innerHTML = `<div class="alert alert-danger mb-0 p-2">${task.message}</div>`;
                        reject(new Error(task.message));
                      } else {
                        if (progressBar) {
                          let p = task.percent;
                          let visualP = 40 + Math.round(p * 0.6); // UI Trick: Processing is 60%
                          progressBar.style.width = visualP + "%";
                          progressBar.innerText = visualP + "%";
                        }
                        if (statusText) statusText.innerText = task.message;
                      }
                    } catch (e) {
                      clearInterval(pollInterval);
                      reject(e);
                    }
                  }, 500);
                } else {
                  reject(new Error("Invalid server response"));
                }
              } catch (e) {
                reject(e);
              }
            } else {
              reject(new Error("Upload failed: " + xhr.status));
            }
          };
          xhr.onerror = () => reject(new Error("Network error"));
          xhr.send(formData);
        });
      }
    </script>
  </body>
</html>
