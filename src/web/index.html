<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>P2P Storage Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
  </head>
  <body class="bg-light">
    <div class="container py-4">
      <header class="pb-3 mb-4 border-bottom d-flex justify-content-between align-items-center">
        <a href="/" class="d-flex align-items-center text-dark text-decoration-none">
          <span class="fs-4">P2P Storage System</span>
        </a>
        <nav>
            <a href="/" class="btn btn-primary me-2">Dashboard</a>
            <a href="/filesystem" class="btn btn-outline-primary me-2">Filesystem</a>
            <a href="/topology" class="btn btn-outline-primary">Network Topology</a>
        </nav>
      </header>

      <div class="row g-4 mb-4">
        <!-- Left Column -->
        <div class="col-lg-6 d-flex flex-column gap-4">
          
          <!-- Upload Card -->
          <div class="card">
            <div class="card-header bg-primary text-white">Upload New File</div>
            <div class="card-body">
              <form id="uploadForm">
                <div class="mb-3">
                  <label for="fileInput" class="form-label">Select File</label>
                  <input class="form-control" type="file" id="fileInput" required />
                </div>

                <div class="row g-2 mb-3">
                  <div class="col-md-6">
                    <label for="replicasInput" class="form-label">Replicas (Redundancy)</label>
                    <input type="number" class="form-control" id="replicasInput" value="5" min="1" max="10" />
                    <div class="form-text">Copies of each chunk.</div>
                  </div>
                  <div class="col-md-6 d-flex align-items-center">
                    <div class="form-check mt-4">
                      <input class="form-check-input" type="checkbox" value="" id="compressionCheck" checked />
                      <label class="form-check-label" for="compressionCheck"> Enable Compression (LZMA) </label>
                    </div>
                  </div>
                </div>

                <button type="submit" class="btn btn-success">Distribute to Network</button>
              </form>
              <div id="uploadStatus" class="mt-3"></div>
            </div>
          </div>

          <!-- Public Catalog Card -->
          <div class="card flex-grow-1">
            <div class="card-header bg-dark text-white d-flex justify-content-between align-items-center">
              <span>üåç Public Network Catalog</span>
              <button class="btn btn-sm btn-outline-light" onclick="loadCatalog()">Refresh</button>
            </div>
            <div class="card-body p-0">
              <div class="table-responsive" style="max-height: 400px">
                <table class="table table-striped table-hover mb-0">
                  <thead class="table-light">
                    <tr>
                      <th>Filename</th>
                      <th>Manifest ID</th>
                      <th>Size</th>
                      <th style="width: 200px; min-width: 200px">Actions</th>
                    </tr>
                  </thead>
                  <tbody id="catalogList">
                    <tr>
                      <td colspan="4" class="text-center text-muted py-3">Click Refresh to discover files...</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>

        </div>

        <!-- Right Column -->
        <div class="col-lg-6 d-flex flex-column gap-4">

          <!-- Download Card -->
          <div class="card">
            <div class="card-header bg-dark text-white">Download from Network</div>
            <div class="card-body">
              <div class="input-group">
                <input type="text" id="manifestIdInput" class="form-control" placeholder="Enter Manifest Hash ID (64 chars)" aria-label="Manifest Hash" />
                <button class="btn btn-primary" type="button" onclick="downloadByManifestId()">Download</button>
              </div>
              <div class="form-text">Paste a Manifest ID to fetch the file directly from the network.</div>
            </div>
          </div>

        </div>
      </div>

      <!-- Modal for Distribution Graph -->
      <div class="modal fade" id="distModal" tabindex="-1">
        <div class="modal-dialog modal-xl">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">File Distribution Map</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
              <div id="dist-graph" style="width: 100%; height: 500px; border: 1px solid #ddd"></div>
            </div>
          </div>
        </div>
      </div>

      <footer class="pt-3 mt-4 text-muted border-top">&copy; 2026 P2P Storage System</footer>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      function formatBytes(bytes, decimals = 2) {
        if (!+bytes) return "0 Bytes";
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
      }

      // --- Manifests ---

      function downloadByManifestId() {
        const input = document.getElementById("manifestIdInput");
        const id = input.value.trim();

        if (!id) {
          alert("Please enter a Manifest ID.");
          return;
        }
        if (id.length !== 64) {
          alert("Invalid ID length. A valid Manifest Hash must be 64 characters.");
          return;
        }

        // Trigger stream download
        window.location.href = `/api/stream_id/${id}`;
      }

      async function loadManifests() {
        try {
          const res = await fetch("/api/manifests");
          const data = await res.json();
          const list = document.getElementById("manifestList");
          list.innerHTML = "";
          if (data.length === 0) {
            list.innerHTML = '<li class="list-group-item text-center">No manifests found</li>';
            return;
          }
          data.forEach((item) => {
            // Handle both legacy string format (if cached) or new object format
            const name = item.filename || item;
            const size = item.size ? formatBytes(item.size) : "N/A";
            const cleanName = name; // Name is already clean from backend

            const li = document.createElement("li");
            li.className = "list-group-item d-flex justify-content-between align-items-center";
            li.innerHTML = `
                    <div class="d-flex align-items-center flex-grow-1 overflow-hidden">
                        <span class="text-truncate fw-bold me-2" title="${cleanName}">${cleanName}</span>
                        <span class="badge bg-light text-secondary border">${size}</span>
                    </div>
                    <div class="btn-group ms-2">
                        <button class="btn btn-sm btn-outline-info" onclick="showDistributionGraph('${cleanName}')" title="View Map">Map</button>
                        <button class="btn btn-sm btn-outline-primary" onclick="downloadFile('${cleanName}')" title="Download to Server">Get</button>
                        <button class="btn btn-sm btn-outline-success" onclick="streamDownload('${cleanName}')" title="Download Directly to Browser">Stream</button>
                        <button class="btn btn-sm btn-outline-warning" onclick="repairFile('${cleanName}')" title="Check Health & Repair">Fix</button>
                        <button class="btn btn-sm btn-outline-danger" onclick="deleteManifest('${cleanName}')" title="Delete">Del</button>
                    </div>
                `;
            list.appendChild(li);
          });
        } catch (e) {
          console.error(e);
        }
      }

      function streamDownload(manifestName) {
        if (!confirm(`Stream download ${manifestName} directly? This depends on your browser to save the file.`)) return;
        window.location.href = `/api/stream/${manifestName}`;
      }

      async function deleteManifest(name) {
        if (!confirm(`Are you sure you want to delete ${name} and all its chunks from the network? This cannot be undone.`)) return;

        try {
          const res = await fetch(`/api/manifests/${name}`, { method: "DELETE" });
          const result = await res.json();

          if (res.ok) {
            // alert(result.message);
            loadManifests(); // Refresh list
            loadCatalog(); // Refresh public catalog as well
          } else {
            alert("Error: " + (result.error || result.message));
          }
        } catch (e) {
          alert("Network error deleting manifest");
        }
      }

      async function pruneOrphans() {
        if (!confirm("Delete all orphan chunks (chunks not referenced by any manifest)? This frees up space but is irreversible.")) return;
        try {
          const res = await fetch("/api/prune", { method: "POST" });
          const result = await res.json();
          if (res.ok) {
            alert(result.message);
          } else {
            alert("Error: " + result.message);
          }
        } catch (e) {
          alert("Network error: " + e);
        }
      }

      // Global variable to track distribution network instance
      let distNetwork = null;

      async function showDistributionGraph(identifier, isPublic = false) {
        const modal = new bootstrap.Modal(document.getElementById("distModal"));
        modal.show();

        const graphContainer = document.getElementById("dist-graph");
        // Clear and show loading state
        graphContainer.innerHTML =
          '<div class="d-flex justify-content-center align-items-center h-100 flex-column"><div class="spinner-border text-primary"></div><div class="mt-2 text-muted">Discovery in progress...</div></div>';

        try {
          const url = isPublic ? `/api/manifests/id/${identifier}` : `/api/manifests/${identifier}`;
          const res = await fetch(url);
          if (!res.ok) throw new Error("Failed to load map data");
          const manifest = await res.json();

          // Clear loading spinner
          graphContainer.innerHTML = "";

          const nodes = [];
          const edges = [];
          const ids = new Set();

          // 1. Root Node (File) is just the entry point visually but we focus on Hosts
          // But user requirement: Nodes = HOSTS, Edges = CHUNKS.

          const sortedChunks = manifest.chunks.sort((a, b) => a.index - b.index);

          // Collect all unique Hosts first to create specific nodes
          const hostSet = new Set();
          sortedChunks.forEach((c) => {
            (c.locations || []).forEach((loc) => hostSet.add(loc));
          });

          // Add Hosts as Nodes
          hostSet.forEach((loc) => {
            const label = loc.split(":").pop();
            nodes.push({
              id: loc,
              label: label,
              color: "#4CAF50",
              size: 25,
              shape: "ellipse",
            });
            ids.add(loc);
          });

          // Add Start Node (Source)
          nodes.push({ id: "SOURCE", label: "START", color: "#FF9800", size: 30, shape: "database" });
          ids.add("SOURCE");

          // Build edges based on sequence: SOURCE -> Chunks(0) -> Chunks(1) ...
          let prevHosts = ["SOURCE"];

          sortedChunks.forEach((chunk, idx) => {
            const chunkLabel = `C${chunk.index}`;
            const currentHosts = chunk.locations || [];

            if (currentHosts.length > 0) {
              // Connect all prev hosts to all current hosts representing this chunk step
              // To avoid "mesh" mess, we try to be sparse?
              // User asked for "sparse graph", "hosts are nodes", "chunks are edges".

              // If we connect Prev -> Next with label "C(n)", it implies moving from Prev to get next part.

              // Strategy: Pick 1 best path or show all?
              // "Sparse" suggests minimalistic. Lets connect 1-to-1 if possible or round robin.

              const uniqueCurr = [...new Set(currentHosts)];

              if (prevHosts.length > 0) {
                // Connect each previous host to one current host to create a path
                // Or connect primary replica.

                // Visualizing "Flow":
                uniqueCurr.forEach((curr, currIdx) => {
                  // Try to find a "parent" from prevHosts to connect from.
                  // Modulo mapping to keep it sparse (1 incoming edge per node roughly)

                  let prev = prevHosts[currIdx % prevHosts.length];

                  // Avoid self-loops if possible, unless necessary (same host has C1 and C2)
                  // Vis.js handles self-loops fine.

                  edges.push({
                    from: prev,
                    to: curr,
                    label: chunkLabel,
                    arrows: "to",
                    color: "#2196F3",
                    font: { align: "horizontal", size: 10, background: "white" },
                  });
                });
              }
              prevHosts = uniqueCurr;
            } else {
              // Break in chain
              prevHosts = [];
            }
          });

          const container = document.getElementById("dist-graph");
          const data = { nodes: nodes, edges: edges };

          // Disable hierarchical layout to prevent "vertical column" issues with cyclic graphs.
          // Use physics (BarnesHut) to create an organic, sparse graph.
          const options = {
            layout: {
              improvedLayout: true,
              randomSeed: 2, // Deterministic layout
            },
            physics: {
              enabled: true,
              solver: "barnesHut",
              barnesHut: {
                gravitationalConstant: -2000,
                centralGravity: 0.3,
                springLength: 200,
                springConstant: 0.04,
                damping: 0.09,
                avoidOverlap: 0.5,
              },
              stabilization: {
                iterations: 1000,
              },
            },
            edges: {
              smooth: {
                type: "continuous",
              },
            },
          };

          // Wait for modal and destroy previous
          setTimeout(() => {
            if (distNetwork) distNetwork.destroy();
            distNetwork = new vis.Network(container, data, options);
          }, 500);
        } catch (e) {
          document.getElementById("dist-graph").innerText = "Error loading map: " + e;
        }
      }

      async function downloadFile(manifestName) {
        // if (!confirm(`Download file from ${manifestName}?`)) return;
        try {
          const statusDiv = document.getElementById("uploadStatus"); // Reusing status div

          // Show progress bar
          statusDiv.innerHTML = `
            <div class="progress mb-2" style="height: 25px;">
                <div id="downloadBar" class="progress-bar progress-bar-striped progress-bar-animated bg-info text-dark" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
            </div>
            <div id="downloadStatusText" class="text-muted small">Preparing download for ${manifestName}...</div>
          `;

          const res = await fetch("/api/download", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ manifest: manifestName }),
          });
          const result = await res.json();

          if (result.status === "processing" && result.task_id) {
            const taskId = result.task_id;
            const progressBar = document.getElementById("downloadBar");
            const statusText = document.getElementById("downloadStatusText");

            const pollInterval = setInterval(async () => {
              try {
                const r = await fetch(`/api/progress/${taskId}`);
                const task = await r.json();

                if (task.status === "completed") {
                  clearInterval(pollInterval);
                  if (progressBar) {
                    progressBar.style.width = "100%";
                    progressBar.innerText = "Ready";
                    progressBar.classList.remove("progress-bar-animated");
                    progressBar.classList.add("bg-success", "text-white");
                  }
                  statusDiv.innerHTML = `<div class="alert alert-success">Download ready!</div>`;

                  // Trigger browser download if URL provided
                  if (task.download_url) {
                    const a = document.createElement("a");
                    a.href = task.download_url;
                    a.download = manifestName.replace(".manifest", "");
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                  }

                  setTimeout(() => {
                    statusDiv.innerHTML = "";
                  }, 3000);
                } else if (task.status === "error") {
                  clearInterval(pollInterval);
                  statusDiv.innerHTML = `<div class="alert alert-danger">Error: ${task.message}</div>`;
                } else {
                  // Update progress
                  if (progressBar) {
                    progressBar.style.width = task.percent + "%";
                    progressBar.innerText = task.percent + "%";
                  }
                  if (statusText) statusText.innerText = task.message;
                }
              } catch (e) {
                console.error("Polling error", e);
              }
            }, 1000);
          } else if (result.status === "ok" && result.download_url) {
            // Legacy/Fast path (if sync)
            statusDiv.innerHTML = `<div class="alert alert-success">Download started!</div>`;

            // Trigger browser download
            const a = document.createElement("a");
            a.href = result.download_url;
            a.download = manifestName.replace(".manifest", "");
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            // Hide alert after 3s
            setTimeout(() => {
              statusDiv.innerHTML = "";
            }, 3000);
          } else {
            statusDiv.innerHTML = `<div class="alert alert-danger">Error: ${result.message}</div>`;
          }
        } catch (e) {
          alert("Error triggering download: " + e);
        }
      }

      // --- Catalog ---
      async function loadCatalog() {
        const tbody = document.getElementById("catalogList");
        tbody.innerHTML = '<tr><td colspan="4" class="text-center"><div class="spinner-border spinner-border-sm text-primary"></div> Searching Network...</td></tr>';

        try {
          const res = await fetch("/api/catalog");
          const data = await res.json();

          if (data.error) {
            tbody.innerHTML = `<tr><td colspan="4" class="text-center text-danger">Error: ${data.error}</td></tr>`;
            return;
          }

          if (data.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">No public files found in discovery.</td></tr>';
            return;
          }

          tbody.innerHTML = "";
          data.forEach((item) => {
            const tr = document.createElement("tr");
            tr.innerHTML = `
                    <td class="fw-bold">${item.name}</td>
                    <td><code class="user-select-all small">${item.id}</code></td>
                    <td>${formatBytes(item.size || 0)}</td>
                    <td style="white-space: nowrap;">
                        <button class="btn btn-sm btn-outline-info" onclick="showDistributionGraph('${
                          item.id
                        }', true)" title="View Map"><i class="fas fa-project-diagram"></i></button>
                        <button class="btn btn-sm btn-primary" onclick="window.location.href='/api/stream_id/${item.id}'" title="Download"><i class="fas fa-download"></i></button>
                        <button class="btn btn-sm btn-outline-danger" onclick="deleteManifest('${item.id}')" title="Delete from Network"><i class="fas fa-trash"></i></button>
                    </td>
                 `;
            tbody.appendChild(tr);
          });
        } catch (e) {
          tbody.innerHTML = `<tr><td colspan="4" class="text-center text-danger">Network Error: ${e}</td></tr>`;
        }
      }

      async function repairFile(manifestName) {
        if (!confirm(`Run health check and repair on ${manifestName}?`)) return;

        const statusDiv = document.getElementById("uploadStatus");
        statusDiv.innerHTML = `
            <div class="progress mb-2" style="height: 25px;">
                <div id="repairBar" class="progress-bar progress-bar-striped progress-bar-animated bg-warning text-dark" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
            </div>
            <div id="repairStatusText" class="text-muted small">Initiating repair...</div>
        `;

        try {
          const res = await fetch("/api/repair", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ manifest: manifestName }),
          });
          const result = await res.json();

          if (result.status === "processing" && result.task_id) {
            const taskId = result.task_id;
            const progressBar = document.getElementById("repairBar");
            const statusText = document.getElementById("repairStatusText");

            const pollInterval = setInterval(async () => {
              try {
                const r = await fetch(`/api/progress/${taskId}`);
                const task = await r.json();

                if (task.status === "completed") {
                  clearInterval(pollInterval);
                  if (progressBar) {
                    progressBar.style.width = "100%";
                    progressBar.innerText = "Done";
                    progressBar.classList.remove("progress-bar-animated");
                    progressBar.classList.add("bg-success", "text-white");
                    progressBar.classList.remove("bg-warning", "text-dark");
                  }
                  if (statusText) statusText.innerText = task.message;

                  loadManifests(); // refresh if locations changed
                  setTimeout(() => {
                    statusDiv.innerHTML = "";
                  }, 5000);
                } else if (task.status === "error") {
                  clearInterval(pollInterval);
                  statusDiv.innerHTML = `<div class="alert alert-danger">${task.message}</div>`;
                } else {
                  if (progressBar) {
                    progressBar.style.width = task.percent + "%";
                    progressBar.innerText = task.percent + "%";
                  }
                  if (statusText) statusText.innerText = task.message;
                }
              } catch (e) {
                console.error(e);
              }
            }, 1000);
          } else {
            statusDiv.innerHTML = `<div class="alert alert-danger">Failed to start repair: ${result.message}</div>`;
          }
        } catch (e) {
          statusDiv.innerHTML = `<div class="alert alert-danger">Network Error</div>`;
        }
      }

      // --- Upload ---
      const uploadForm = document.getElementById("uploadForm");
      if (uploadForm)
        uploadForm.addEventListener("submit", (e) => {
          e.preventDefault();
          const input = document.getElementById("fileInput");
          if (!input.files[0]) return;

          const file = input.files[0];
          const replicas = document.getElementById("replicasInput").value || 5;
          const compression = document.getElementById("compressionCheck").checked;

          // Capture current path at moment of upload start
          // const targetFsPath = currentFsPath;

          const formData = new FormData();
          formData.append("file", file);
          formData.append("redundancy", replicas);
          formData.append("compression", compression);

          const statusDiv = document.getElementById("uploadStatus");
          // Reset status with a progress bar
          statusDiv.innerHTML = `
            <div class="progress mb-2" style="height: 25px;">
                <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
            </div>
            <div id="statusText" class="text-muted small">Starting upload...</div>
        `;

          const xhr = new XMLHttpRequest();
          xhr.open("POST", "/api/upload", true);

          xhr.upload.onprogress = (event) => {
            if (event.lengthComputable) {
              const percent = Math.round((event.loaded / event.total) * 100);
              const progressBar = document.getElementById("progressBar");
              const statusText = document.getElementById("statusText");

              // UX: Map Upload (0-100%) to first 40% of total progress bar
              // This reserves 60% for the server-side distribution/processing
              const visualPercent = Math.round(percent * 0.4);

              if (progressBar) {
                progressBar.style.width = visualPercent + "%";
                progressBar.innerText = visualPercent + "%";
                progressBar.setAttribute("aria-valuenow", visualPercent);
              }

              if (statusText) {
                if (percent < 100) {
                  statusText.innerText = `Uploading: ${formatBytes(event.loaded)} / ${formatBytes(event.total)}`;
                } else {
                  statusText.innerText = "Upload complete. Sending to server...";
                }
              }
            }
          };

          xhr.onload = () => {
            if (xhr.status === 200) {
              try {
                const result = JSON.parse(xhr.responseText);

                if (result.status === "processing" && result.task_id) {
                  // Start polling for progress
                  const taskId = result.task_id;
                  const progressBar = document.getElementById("progressBar");
                  const statusText = document.getElementById("statusText");

                  // Switch visual style to indicate phase change
                  if (progressBar) {
                    progressBar.classList.remove("bg-primary");
                    progressBar.classList.add("bg-success", "progress-bar-striped", "progress-bar-animated");
                  }

                  const pollInterval = setInterval(async () => {
                    try {
                      const res = await fetch(`/api/progress/${taskId}`);
                      const task = await res.json();

                      if (task.status === "completed") {
                        clearInterval(pollInterval);

                        // Make sure bar is at 100%
                        if (progressBar) {
                          progressBar.style.width = "100%";
                          progressBar.innerText = "100%";
                          progressBar.setAttribute("aria-valuenow", 100);
                          progressBar.classList.remove("progress-bar-animated");
                        }
                        if (statusText) {
                          statusText.className = "text-success fw-bold";
                          // Use the backend message which contains the ID
                          statusText.innerText = task.message;
                        }

                        // Try to extract Manifest ID for better visibility
                        const match = task.message.match(/Manifest ID: ([a-f0-9]{64})/i);
                        if (match && match[1]) {
                          const manifestId = match[1];
                          const alertHtml = `
                                <div class="alert alert-success mt-2">
                                    <strong>Build Success!</strong><br>
                                    Manifest ID: <code class="user-select-all">${manifestId}</code><br>
                                    <small class="text-muted">(Share this ID for direct download)</small>
                                </div>
                             `;
                          statusDiv.innerHTML += alertHtml;

                          // Always add to filesystem at the captured path
                          // addFileToFs(manifestId, file.name, file.size, targetFsPath);
                        }

                        loadManifests();

                        // Auto-hide after 3 seconds
                        setTimeout(() => {
                          statusDiv.innerHTML = "";
                        }, 3000);
                      } else if (task.status === "error") {
                        clearInterval(pollInterval);
                        statusDiv.innerHTML = `<div class="alert alert-danger">Error: ${task.message}</div>`;
                      } else {
                        // Update progress
                        if (progressBar) {
                          let p = task.percent;
                          // Map Distribution (0-100%) to remaining 60% of total bar (40 -> 100)
                          let visualP = 40 + Math.round(p * 0.6);

                          progressBar.style.width = visualP + "%";
                          progressBar.innerText = visualP + "%";
                          progressBar.setAttribute("aria-valuenow", visualP);
                        }
                        if (statusText) {
                          statusText.innerText = task.message;
                        }
                      }
                    } catch (e) {
                      console.error("Polling error", e);
                    }
                  }, 500);
                } else if (result.status === "ok") {
                  statusDiv.innerHTML = `<div class="alert alert-success">${result.message}</div>`;
                  loadManifests(); // Refresh list
                } else {
                  statusDiv.innerHTML = `<div class="alert alert-danger">Error: ${result.message}</div>`;
                }
              } catch (e) {
                statusDiv.innerHTML = `<div class="alert alert-danger">Invalid server response</div>`;
              }
            } else {
              statusDiv.innerHTML = `<div class="alert alert-danger">Upload Failed (Status ${xhr.status})</div>`;
            }
          };

          xhr.onerror = () => {
            statusDiv.innerHTML = `<div class="alert alert-danger">Network Error during upload</div>`;
          };

          xhr.send(formData);
        });

      // Init
      document.addEventListener("DOMContentLoaded", function () {
        console.log("Initializing Dashboard...");
        loadManifests();
      });
      // Refresh manifest list every 10 sec
      setInterval(loadManifests, 10000);



    </script>
  </body>
</html>
