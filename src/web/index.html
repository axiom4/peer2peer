<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>P2P Storage Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
      #network-graph {
        width: 100%;
        height: 500px;
        border: 1px solid lightgray;
        background-color: #f8f9fa;
      }
    </style>
  </head>
  <body class="bg-light">
    <div class="container py-4">
      <header class="pb-3 mb-4 border-bottom">
        <a href="/" class="d-flex align-items-center text-dark text-decoration-none">
          <span class="fs-4">P2P Storage System</span>
        </a>
      </header>

      <div class="row mb-4">
        <div class="col-md-6">
          <div class="card h-100">
            <div class="card-header bg-primary text-white">Upload New File</div>
            <div class="card-body">
              <form id="uploadForm">
                <div class="mb-3">
                  <label for="fileInput" class="form-label">Select File</label>
                  <input class="form-control" type="file" id="fileInput" required />
                </div>

                <div class="row g-2 mb-3">
                  <div class="col-md-6">
                    <label for="replicasInput" class="form-label">Replicas (Redundancy)</label>
                    <input type="number" class="form-control" id="replicasInput" value="5" min="1" max="10" />
                    <div class="form-text">Copies of each chunk.</div>
                  </div>
                  <div class="col-md-6 d-flex align-items-center">
                    <div class="form-check mt-4">
                      <input class="form-check-input" type="checkbox" value="" id="compressionCheck" checked />
                      <label class="form-check-label" for="compressionCheck"> Enable Compression (LZMA) </label>
                    </div>
                  </div>
                </div>

                <button type="submit" class="btn btn-success">Distribute to Network</button>
              </form>
              <div id="uploadStatus" class="mt-3"></div>
            </div>
          </div>
        </div>
        <div class="col-md-6">
          <div class="card h-100">
            <div class="card-header bg-info text-white">Available Manifests</div>
            <div class="card-body">
              <ul id="manifestList" class="list-group">
                <li class="list-group-item text-center">Loading...</li>
              </ul>
            </div>
          </div>
        </div>
      </div>

      <div class="row mb-4">
        <div class="col-12">
          <div class="card">
            <div class="card-header bg-secondary text-white d-flex justify-content-between align-items-center">
              <span>Network Topology</span>
              <button class="btn btn-sm btn-light" onclick="loadGraph()">Refresh Graph</button>
            </div>
            <div class="card-body p-0">
              <div id="network-graph"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Modal for Distribution Graph -->
      <div class="modal fade" id="distModal" tabindex="-1">
        <div class="modal-dialog modal-xl">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">File Distribution Map</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
              <div id="dist-graph" style="width: 100%; height: 500px; border: 1px solid #ddd"></div>
            </div>
          </div>
        </div>
      </div>

      <footer class="pt-3 mt-4 text-muted border-top">&copy; 2026 P2P Storage System</footer>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      function formatBytes(bytes, decimals = 2) {
        if (!+bytes) return "0 Bytes";
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
      }

      // --- Manifests ---
      async function loadManifests() {
        try {
          const res = await fetch("/api/manifests");
          const data = await res.json();
          const list = document.getElementById("manifestList");
          list.innerHTML = "";
          if (data.length === 0) {
            list.innerHTML = '<li class="list-group-item text-center">No manifests found</li>';
            return;
          }
          data.forEach((item) => {
            // Handle both legacy string format (if cached) or new object format
            const name = item.filename || item;
            const size = item.size ? formatBytes(item.size) : "N/A";
            const cleanName = name; // Name is already clean from backend

            const li = document.createElement("li");
            li.className = "list-group-item d-flex justify-content-between align-items-center";
            li.innerHTML = `
                    <div class="d-flex align-items-center flex-grow-1 overflow-hidden">
                        <span class="text-truncate fw-bold me-2" title="${cleanName}">${cleanName}</span>
                        <span class="badge bg-light text-secondary border">${size}</span>
                    </div>
                    <div class="btn-group ms-2">
                        <button class="btn btn-sm btn-outline-info" onclick="showDistributionGraph('${cleanName}')" title="View Map">Map</button>
                        <button class="btn btn-sm btn-outline-primary" onclick="downloadFile('${cleanName}')" title="Download to Server">Get</button>
                        <button class="btn btn-sm btn-outline-success" onclick="streamDownload('${cleanName}')" title="Download Directly to Browser">Stream</button>
                        <button class="btn btn-sm btn-outline-warning" onclick="repairFile('${cleanName}')" title="Check Health & Repair">Fix</button>
                        <button class="btn btn-sm btn-outline-danger" onclick="deleteManifest('${cleanName}')" title="Delete">Del</button>
                    </div>
                `;
            list.appendChild(li);
          });
        } catch (e) {
          console.error(e);
        }
      }

      function streamDownload(manifestName) {
        if (!confirm(`Stream download ${manifestName} directly? This depends on your browser to save the file.`)) return;
        window.location.href = `/api/stream/${manifestName}`;
      }

      async function deleteManifest(name) {
        if (!confirm(`Are you sure you want to delete ${name} and all its chunks from the network? This cannot be undone.`)) return;

        try {
          const res = await fetch(`/api/manifests/${name}`, { method: "DELETE" });
          const result = await res.json();

          if (res.ok) {
            // alert(result.message);
            loadManifests(); // Refresh list
          } else {
            alert("Error: " + (result.error || result.message));
          }
        } catch (e) {
          alert("Network error deleting manifest");
        }
      }

      // Global variable to track distribution network instance
      let distNetwork = null;

      async function showDistributionGraph(name) {
        const modal = new bootstrap.Modal(document.getElementById("distModal"));
        modal.show();

        try {
          const res = await fetch(`/api/manifests/${name}`);
          const manifest = await res.json();

          const nodes = [];
          const edges = [];
          const ids = new Set();

          // 1. Root Node (File) is just the entry point visually but we focus on Hosts
          // But user requirement: Nodes = HOSTS, Edges = CHUNKS.

          const sortedChunks = manifest.chunks.sort((a, b) => a.index - b.index);

          // Collect all unique Hosts first to create specific nodes
          const hostSet = new Set();
          sortedChunks.forEach((c) => {
            (c.locations || []).forEach((loc) => hostSet.add(loc));
          });

          // Add Hosts as Nodes
          hostSet.forEach((loc) => {
            const label = loc.split(":").pop();
            nodes.push({
              id: loc,
              label: label,
              color: "#4CAF50",
              size: 25,
              shape: "ellipse",
            });
            ids.add(loc);
          });

          // Add Start Node (Source)
          nodes.push({ id: "SOURCE", label: "START", color: "#FF9800", size: 30, shape: "database" });
          ids.add("SOURCE");

          // Build edges based on sequence: SOURCE -> Chunks(0) -> Chunks(1) ...
          let prevHosts = ["SOURCE"];

          sortedChunks.forEach((chunk, idx) => {
            const chunkLabel = `C${chunk.index}`;
            const currentHosts = chunk.locations || [];

            if (currentHosts.length > 0) {
              // Connect all prev hosts to all current hosts representing this chunk step
              // To avoid "mesh" mess, we try to be sparse?
              // User asked for "sparse graph", "hosts are nodes", "chunks are edges".

              // If we connect Prev -> Next with label "C(n)", it implies moving from Prev to get next part.

              // Strategy: Pick 1 best path or show all?
              // "Sparse" suggests minimalistic. Lets connect 1-to-1 if possible or round robin.

              const uniqueCurr = [...new Set(currentHosts)];

              if (prevHosts.length > 0) {
                // Connect each previous host to one current host to create a path
                // Or connect primary replica.

                // Visualizing "Flow":
                uniqueCurr.forEach((curr, currIdx) => {
                  // Try to find a "parent" from prevHosts to connect from.
                  // Modulo mapping to keep it sparse (1 incoming edge per node roughly)

                  let prev = prevHosts[currIdx % prevHosts.length];

                  // Avoid self-loops if possible, unless necessary (same host has C1 and C2)
                  // Vis.js handles self-loops fine.

                  edges.push({
                    from: prev,
                    to: curr,
                    label: chunkLabel,
                    arrows: "to",
                    color: "#2196F3",
                    font: { align: "horizontal", size: 10, background: "white" },
                  });
                });
              }
              prevHosts = uniqueCurr;
            } else {
              // Break in chain
              prevHosts = [];
            }
          });

          const container = document.getElementById("dist-graph");
          const data = { nodes: nodes, edges: edges };

          // Disable hierarchical layout to prevent "vertical column" issues with cyclic graphs.
          // Use physics (BarnesHut) to create an organic, sparse graph.
          const options = {
            layout: {
              improvedLayout: true,
              randomSeed: 2, // Deterministic layout
            },
            physics: {
              enabled: true,
              solver: "barnesHut",
              barnesHut: {
                gravitationalConstant: -2000,
                centralGravity: 0.3,
                springLength: 200,
                springConstant: 0.04,
                damping: 0.09,
                avoidOverlap: 0.5,
              },
              stabilization: {
                iterations: 1000,
              },
            },
            edges: {
              smooth: {
                type: "continuous",
              },
            },
          };

          // Wait for modal and destroy previous
          setTimeout(() => {
            if (distNetwork) distNetwork.destroy();
            distNetwork = new vis.Network(container, data, options);
          }, 500);
        } catch (e) {
          document.getElementById("dist-graph").innerText = "Error loading map: " + e;
        }
      }

      async function downloadFile(manifestName) {
        // if (!confirm(`Download file from ${manifestName}?`)) return;
        try {
          const statusDiv = document.getElementById("uploadStatus"); // Reusing status div

          // Show progress bar
          statusDiv.innerHTML = `
            <div class="progress mb-2" style="height: 25px;">
                <div id="downloadBar" class="progress-bar progress-bar-striped progress-bar-animated bg-info text-dark" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
            </div>
            <div id="downloadStatusText" class="text-muted small">Preparing download for ${manifestName}...</div>
          `;

          const res = await fetch("/api/download", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ manifest: manifestName }),
          });
          const result = await res.json();

          if (result.status === "processing" && result.task_id) {
            const taskId = result.task_id;
            const progressBar = document.getElementById("downloadBar");
            const statusText = document.getElementById("downloadStatusText");

            const pollInterval = setInterval(async () => {
              try {
                const r = await fetch(`/api/progress/${taskId}`);
                const task = await r.json();

                if (task.status === "completed") {
                  clearInterval(pollInterval);
                  if (progressBar) {
                    progressBar.style.width = "100%";
                    progressBar.innerText = "Ready";
                    progressBar.classList.remove("progress-bar-animated");
                    progressBar.classList.add("bg-success", "text-white");
                  }
                  statusDiv.innerHTML = `<div class="alert alert-success">Download ready!</div>`;

                  // Trigger browser download if URL provided
                  if (task.download_url) {
                    const a = document.createElement("a");
                    a.href = task.download_url;
                    a.download = manifestName.replace(".manifest", "");
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                  }

                  setTimeout(() => {
                    statusDiv.innerHTML = "";
                  }, 3000);
                } else if (task.status === "error") {
                  clearInterval(pollInterval);
                  statusDiv.innerHTML = `<div class="alert alert-danger">Error: ${task.message}</div>`;
                } else {
                  // Update progress
                  if (progressBar) {
                    progressBar.style.width = task.percent + "%";
                    progressBar.innerText = task.percent + "%";
                  }
                  if (statusText) statusText.innerText = task.message;
                }
              } catch (e) {
                console.error("Polling error", e);
              }
            }, 1000);
          } else if (result.status === "ok" && result.download_url) {
            // Legacy/Fast path (if sync)
            statusDiv.innerHTML = `<div class="alert alert-success">Download started!</div>`;

            // Trigger browser download
            const a = document.createElement("a");
            a.href = result.download_url;
            a.download = manifestName.replace(".manifest", "");
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            // Hide alert after 3s
            setTimeout(() => {
              statusDiv.innerHTML = "";
            }, 3000);
          } else {
            statusDiv.innerHTML = `<div class="alert alert-danger">Error: ${result.message}</div>`;
          }
        } catch (e) {
          alert("Error triggering download: " + e);
        }
      }

      async function repairFile(manifestName) {
        if (!confirm(`Run health check and repair on ${manifestName}?`)) return;

        const statusDiv = document.getElementById("uploadStatus");
        statusDiv.innerHTML = `
            <div class="progress mb-2" style="height: 25px;">
                <div id="repairBar" class="progress-bar progress-bar-striped progress-bar-animated bg-warning text-dark" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
            </div>
            <div id="repairStatusText" class="text-muted small">Initiating repair...</div>
        `;

        try {
          const res = await fetch("/api/repair", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ manifest: manifestName }),
          });
          const result = await res.json();

          if (result.status === "processing" && result.task_id) {
            const taskId = result.task_id;
            const progressBar = document.getElementById("repairBar");
            const statusText = document.getElementById("repairStatusText");

            const pollInterval = setInterval(async () => {
              try {
                const r = await fetch(`/api/progress/${taskId}`);
                const task = await r.json();

                if (task.status === "completed") {
                  clearInterval(pollInterval);
                  if (progressBar) {
                    progressBar.style.width = "100%";
                    progressBar.innerText = "Done";
                    progressBar.classList.remove("progress-bar-animated");
                    progressBar.classList.add("bg-success", "text-white");
                    progressBar.classList.remove("bg-warning", "text-dark");
                  }
                  if (statusText) statusText.innerText = task.message;

                  loadManifests(); // refresh if locations changed
                  setTimeout(() => {
                    statusDiv.innerHTML = "";
                  }, 5000);
                } else if (task.status === "error") {
                  clearInterval(pollInterval);
                  statusDiv.innerHTML = `<div class="alert alert-danger">${task.message}</div>`;
                } else {
                  if (progressBar) {
                    progressBar.style.width = task.percent + "%";
                    progressBar.innerText = task.percent + "%";
                  }
                  if (statusText) statusText.innerText = task.message;
                }
              } catch (e) {
                console.error(e);
              }
            }, 1000);
          } else {
            statusDiv.innerHTML = `<div class="alert alert-danger">Failed to start repair: ${result.message}</div>`;
          }
        } catch (e) {
          statusDiv.innerHTML = `<div class="alert alert-danger">Network Error</div>`;
        }
      }

      // --- Upload ---
      const uploadForm = document.getElementById("uploadForm");
      if (uploadForm)
        uploadForm.addEventListener("submit", (e) => {
          e.preventDefault();
          const input = document.getElementById("fileInput");
          if (!input.files[0]) return;

          const file = input.files[0];
          const replicas = document.getElementById("replicasInput").value || 5;
          const compression = document.getElementById("compressionCheck").checked;

          const formData = new FormData();
          formData.append("file", file);
          formData.append("redundancy", replicas);
          formData.append("compression", compression);

          const statusDiv = document.getElementById("uploadStatus");
          // Reset status with a progress bar
          statusDiv.innerHTML = `
            <div class="progress mb-2" style="height: 25px;">
                <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
            </div>
            <div id="statusText" class="text-muted small">Starting upload...</div>
        `;

          const xhr = new XMLHttpRequest();
          xhr.open("POST", "/api/upload", true);

          xhr.upload.onprogress = (event) => {
            if (event.lengthComputable) {
              const percent = Math.round((event.loaded / event.total) * 100);
              const progressBar = document.getElementById("progressBar");
              const statusText = document.getElementById("statusText");

              // UX: Map Upload (0-100%) to first 40% of total progress bar
              // This reserves 60% for the server-side distribution/processing
              const visualPercent = Math.round(percent * 0.4);

              if (progressBar) {
                progressBar.style.width = visualPercent + "%";
                progressBar.innerText = visualPercent + "%";
                progressBar.setAttribute("aria-valuenow", visualPercent);
              }

              if (statusText) {
                if (percent < 100) {
                  statusText.innerText = `Uploading: ${formatBytes(event.loaded)} / ${formatBytes(event.total)}`;
                } else {
                  statusText.innerText = "Upload complete. Sending to server...";
                }
              }
            }
          };

          xhr.onload = () => {
            if (xhr.status === 200) {
              try {
                const result = JSON.parse(xhr.responseText);

                if (result.status === "processing" && result.task_id) {
                  // Start polling for progress
                  const taskId = result.task_id;
                  const progressBar = document.getElementById("progressBar");
                  const statusText = document.getElementById("statusText");

                  // Switch visual style to indicate phase change
                  if (progressBar) {
                    progressBar.classList.remove("bg-primary");
                    progressBar.classList.add("bg-success", "progress-bar-striped", "progress-bar-animated");
                  }

                  const pollInterval = setInterval(async () => {
                    try {
                      const res = await fetch(`/api/progress/${taskId}`);
                      const task = await res.json();

                      if (task.status === "completed") {
                        clearInterval(pollInterval);

                        // Make sure bar is at 100%
                        if (progressBar) {
                          progressBar.style.width = "100%";
                          progressBar.innerText = "100%";
                          progressBar.setAttribute("aria-valuenow", 100);
                          progressBar.classList.remove("progress-bar-animated");
                        }
                        if (statusText) {
                          statusText.className = "text-success fw-bold";
                          statusText.innerText = "Distribution Completed Successfully!";
                        }

                        loadManifests();

                        // Auto-hide after 3 seconds
                        setTimeout(() => {
                          statusDiv.innerHTML = "";
                        }, 3000);
                      } else if (task.status === "error") {
                        clearInterval(pollInterval);
                        statusDiv.innerHTML = `<div class="alert alert-danger">Error: ${task.message}</div>`;
                      } else {
                        // Update progress
                        if (progressBar) {
                          let p = task.percent;
                          // Map Distribution (0-100%) to remaining 60% of total bar (40 -> 100)
                          let visualP = 40 + Math.round(p * 0.6);

                          progressBar.style.width = visualP + "%";
                          progressBar.innerText = visualP + "%";
                          progressBar.setAttribute("aria-valuenow", visualP);
                        }
                        if (statusText) {
                          statusText.innerText = task.message;
                        }
                      }
                    } catch (e) {
                      console.error("Polling error", e);
                    }
                  }, 500);
                } else if (result.status === "ok") {
                  statusDiv.innerHTML = `<div class="alert alert-success">${result.message}</div>`;
                  loadManifests(); // Refresh list
                } else {
                  statusDiv.innerHTML = `<div class="alert alert-danger">Error: ${result.message}</div>`;
                }
              } catch (e) {
                statusDiv.innerHTML = `<div class="alert alert-danger">Invalid server response</div>`;
              }
            } else {
              statusDiv.innerHTML = `<div class="alert alert-danger">Upload Failed (Status ${xhr.status})</div>`;
            }
          };

          xhr.onerror = () => {
            statusDiv.innerHTML = `<div class="alert alert-danger">Network Error during upload</div>`;
          };

          xhr.send(formData);
        });

      // --- Graph ---
      let network = null;

      async function loadGraph() {
        const btn = document.querySelector('button[onclick="loadGraph()"]');
        if (btn) {
          btn.disabled = true;
          btn.textContent = "Scanning...";
        }

        try {
          const res = await fetch("/api/network");
          const data = await res.json();

          const container = document.getElementById("network-graph");
          // Check if no nodes found
          if (!data.nodes || data.nodes.length === 0) {
            container.innerHTML =
              '<div class="d-flex justify-content-center align-items-center h-100 text-muted">No nodes found. Ensure nodes are running on the same network.</div>';
            return;
          } else {
            container.innerHTML = ""; // Clear mess
          }

          const options = {
            nodes: {
              shape: "icon",
              icon: {
                face: "'Font Awesome 5 Free'",
                weight: "900",
                code: "\uf233",
                size: 30,
                color: "#0d6efd",
              },
              font: { size: 12, face: "arial", background: "rgba(255,255,255,0.7)" },
              shadow: true,
            },
            edges: {
              arrows: { to: { enabled: true, scaleFactor: 0.5 } },
              color: { color: "#adb5bd", highlight: "#0d6efd", opacity: 0.6 },
              smooth: { type: "continuous" },
              width: 1,
            },
            interaction: {
              hover: true,
              tooltipDelay: 200,
              hideEdgesOnDrag: true,
              multiselect: true,
            },
            physics: {
              enabled: true,
              solver: "forceAtlas2Based",
              forceAtlas2Based: {
                theta: 0.5,
                gravitationalConstant: -50,
                centralGravity: 0.01,
                springConstant: 0.08,
                springLength: 100,
                damping: 0.4,
                avoidOverlap: 0,
              },
              maxVelocity: 50,
              minVelocity: 0.1, // Stop when stable
              stabilization: {
                enabled: true,
                iterations: 1000,
                updateInterval: 50,
                onlyDynamicEdges: false,
                fit: true,
              },
              adaptiveTimestep: true,
            },
            layout: {
              randomSeed: 2,
            },
          };

          // Re-create network
          // Transform data for better display
          const nodes = data.nodes.map((n) => ({
            id: n.id,
            label: n.id.replace("http://", "").replace(":", "\n"), // Stack port
            title: n.id,
          }));

          const edges = data.edges;

          network = new vis.Network(container, { nodes, edges }, options);

          // Add click interaction for highlighting neighbors
          network.on("selectNode", function (params) {
            if (params.nodes.length == 1) {
              const nodeId = params.nodes[0];
              const connectedNodes = network.getConnectedNodes(nodeId);
              // You could implement specific highlighting logic here if needed
              // Vis.js handles basic selection highlighting by default via 'color.highlight'
            }
          });
        } catch (e) {
          console.error("Failed to load graph", e);
          document.getElementById("network-graph").innerHTML = '<div class="alert alert-danger m-3">Failed to load graph data</div>';
        } finally {
          if (btn) {
            btn.disabled = false;
            btn.textContent = "Refresh Graph";
          }
        }
      }

      // Init
      loadManifests();
      loadGraph();
      // Refresh manifest list every 10 sec
      setInterval(loadManifests, 10000);
    </script>
  </body>
</html>
